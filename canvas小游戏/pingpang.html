<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>pingpang</title>
</head>
<body>
    <canvas id="screen" width="400" height="300" style="background-color: darkslategray">
        当前浏览器不支持canvas
    </canvas>
</body>
<script>
class Ball {
    constructor (radius, color, x, y) {
        this.r = radius;
        this.c = color;
        this.px = x; // 圆心
        this.py = y;
        this.vx = 1; // 速度
        this.vy = -1;
        this.ax = 0; // 加速度
        this.ay = 0;
    }

    drawBall(ctx) {
        ctx.save();
        ctx.fillStyle = this.c;
        ctx.beginPath();
        ctx.arc(this.px, this.py, this.r, 0, Math.PI * 2, false);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    move() {
        this.vx += this.ax;
        this.vy += this.ay;
        this.px += this.vx;
        this.py += this.vy;
    }
}

class Block {
    constructor (width, height, color, x, y) {
        this.w = width;
        this.h = height;
        this.c = color;
        this.x = x;
        this.y = y;
        this.show = true;
    }

    drawBlock(ctx) {
        ctx.save();
        ctx.fillStyle = this.c;
        ctx.beginPath();
        ctx.rect(this.x, this.y, this.w, this.h);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

//边缘碰撞检测
function borderCollisionDetect(obj, width, height) {
    if (obj.px - obj.r <= 0 || obj.px + obj.r >= width) {
        return 'xReverse';
    }
    if (obj.py - obj.r <= 0) {
        return 'yReverse';
    }
    if (obj.py - obj.r >= height) {
        return 'gameover';
    }
    return 'moveon';
}

// 两个物体碰撞检测（只有球是运动的，另一个被碰撞的是静止的）obj1矩形 obj2圆形
function objectCollisionDetect(obj1, obj2) {
    let halfOw1 = obj1.w / 2;
    let halfOh1 = obj1.h / 2;
    let r = obj2.r;
    let x1 = obj1.x + halfOw1;
    let y1 = obj1.y + halfOh1;
    let x2 = obj2.px;
    let y2 = obj2.py;
    let abs = Math.abs;
    let pow = Math.pow;

    if (abs(x2 - x1) <= halfOw1 + r && abs(y2 - y1) <= halfOh1 + r) {
        return true;
    }

    if (pow((x2 - x1), 2) + pow((y2 - y1), 2) <= r) {
        return true;
    }

    return false;
}

function startGame(ctx, cw, ch) {
    let pingpang = new Ball(4, 'white', 30, 260);
    let bat = new Block(20, 4, 'white', 190, 260);
    let obstacleArr = [];
    for (let i = 0; i < 5; i++) {
        let x = 0;
        let y = 0;
        y = i * 4;
        for (let j = 0; j < 10; j++) {
            x = Math.floor(Math.random() * 10) * 8 + j * 80;
            let obstacle = new Block(8, 8, 'white', x, y);
            obstacleArr.push(obstacle);
        }
    }
    let score = 0;
    let speed = 1000;
    let levelMap = {
        1: 4,
        2: 10,
        3: 15,
        4: 25,
        5: 50
    }
    let anmation = null;
    let timer = null;

    drawFrame(ctx, function (frameInt) {
        anmation = frameInt;
        let borderCheckResult = borderCollisionDetect(pingpang, cw, ch);
        if (borderCheckResult === 'xReverse') {
            pingpang.vx *= -1;
        } else if (borderCheckResult === 'yReverse') {
            pingpang.vy *= -1;
        }

        if (borderCheckResult === 'gameover') {
            cancelAnimationFrame(anmation);
        }

        obstacleArr.map(item => {
            if (item.show) {
                let obstacleCheckResult = objectCollisionDetect(item, pingpang);
                if (obstacleCheckResult) {
                    item.show = false;
                    pingpang.vy *= -1;
                }
            }
        });

        keyAction(bat);
        let objCheckResult = objectCollisionDetect(bat, pingpang);
        if (objCheckResult) {
            pingpang.vy *= -1;
        }
        pingpang.move();
        pingpang.drawBall(ctx);
        bat.drawBlock(ctx);
        obstacleArr.map(item => {
            if (item.show) {
                item.drawBlock(ctx);
            }
        });
    });

    // autoMove(speed, function (setTimeInt) {
    //     timer = setTimeInt;
    //     pingpang.move();
    // });
}

function drawFrame(ctx, callback) {
    ctx.clearRect(0, 0, 800, 600);
    callback(window.requestAnimationFrame(function () {
        drawFrame(ctx, callback);
    }));
}

function autoMove(speed, callback) {
    let setTimeInt = setTimeout(() => {
        callback(setTimeInt);
        autoMove(speed, callback);
    }, speed);
}

function keyAction(obj) {
    document.onkeydown = function (e) {
        switch (e.keyCode) {
            case 37:
                obj.x -= 4;
                if (obj.x < 0) {
                    obj.x = 0;
                }
                break;
            case 39:
                obj.x += 4;
                if (obj.x > 380) {
                    obj.x = 380;
                }
                break;
            default:
                break;
        }
    }
}

function getLevel(score) {
    let level = 1;
    switch (score) {
        case score < 10:
            level = 1;
            break;
        case score >= 10 && score < 30:
            level = 2;
            break;
        case score >= 30 && score < 60:
            level = 3;
            break;
        case score >= 60 && score < 110:
            level = 4;
            break;
        case score >= 110:
            level = 5;
            break;
        default:
            break;
    }
}
window.onload = function () {
    let canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');
    let cw = canvas.width;
    let ch = canvas.height;

    startGame(ctx, cw, ch);
};
</script>
</html>